Collection Framework:

	Why?
		Array object within Java is limited to work with. Mainly the array is immutable. I could create my own custom version of an array, 
		but it'll likely be poorly optimised and it'll be difficult to share the data structure between developers. This is where the 
		Collection Framework comes in:

	Called a framework (more akin to a library). Provides interfaces and classes that allow deveopers to more easily manage groups of objects.
	A 'collection' object is designed to stored to a group of objects. It gives you more flexibilities.

	Advantages:
		Reduces effort (provides data structures and algorithms for you)
		Increases performance (creates fine-tuned implementations of data structure and algorithms)
		Encourages software reuse (provides a standard interface)

	BUT!
		Does not allow primitive data types, need to use Wrapper classes to convert into objects. 
		int -> Integer
		boolean -> Boolean
		byte -> Byte
		The process of converting a primitive data types into its Wrapper class is called boxing(autoboxing).
		From Wrapper Class to primitive -> unboxing

	Main interfaces:
		Set 
			Do not allow duplicates
			Do not guarantee insertion order
			(Only inherits methods from the Collection + restriction to duplicate)
			Sets are equal if they contain the same elements. 

			Classes:
				HashSet : (Maintains no order, stores in hash table, best performance)
				LinkedHashSet (Maintains insertion order, linked list running through it, weaker performance) 
				TreeSet (Maintains value order, red-black tree, very slow)
				
				HashSet vs TreeSet:
					HashSet allows null values and hetrogenous objects, TreeSet does not because of compareTo() method.
					
		List
			An ordered collection. 
			May contain duplicate elements.
			Access via index (positional access) : interact with elements based on their numerical position in the list. 
								(get, set, add, addAll and remove)
			Search : find a specified object in the list and return its position. (indexOf and lastIndexOf)
			Iteration : extends 'Iterator' to utilise the list's sequential nature
			Range-view : Perform arbitary range operations (sublist)

			Lists have to contain the same elements in the same position to be equal

			Classes:
				ArrayList:
					A resizable array (mutable) compared to the built in array inside Java. Allows you to add and remove 
					elements. (syntax is different to array)
				LinkedList:
					Consists of nodes, each node will store a value and a 'pointer' to the next node. Allows for easier 
					addition and removal for entries (ArrayLists have to resize the entire structure). However requires more
					memory overhead, each node holds the data plus addresses to other nodes.
				Vector:
					Depcreated (contains legacy methods), but is synchronised
				
		Queue
			Ordered list of objects related to insertion order.
			Follows the FIFO (First-In-First-Out) principle. 
			Methods:
				poll,remove,peek and element

			Classes:
				LinkedList: 
					(Look at List Definition)
				PriorityQueue:
					Doesn't permit null
					Can't store hetrogenous objects
					Unbounded queues.


					